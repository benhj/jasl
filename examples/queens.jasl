// ----------------------------------------------
// A script to solve the N-Queens problem,
// a problem whereby no queen should be attacked
// by another queen.
// For example, for 8-queens, the solution might
// eventually be:
//
// [- - - - - - Q -]
// [- - - Q - - - -]
// [- Q - - - - - -]
// [- - - - - - - Q]
// [- - - - - Q - -]
// [Q - - - - - - -]
// [- - Q - - - - -]
// [- - - - Q - - -]
// ----------------------------------------------

fn:list initialize (N) -> rep {

    // build the representation
    list [] -> rep;
    int 0 -> i;
    // board initialization with heuristic
    repeat N times {
        string i -> istring;
        add_token(istring, rep);
        int (i + 2) -> i;
        ? (i == N) {
            int 0 -> i;
        }
    }
}

block showBoard (N, representation) {

    // create one of the rows of the board
    list [] -> row;
    repeat N times {
        add_token ("-", row);
    }

    // create the board representation
    int 0 -> i;
    repeat N times {
        // make sure correct '-' is set with a 'Q'
        get_token(i, representation) -> token;

        // token is a string to needs to be
        // converted to an int
        int token -> itoken;

        // now set the token to a 'Q'
        set_token(itoken, row, "Q") -> theRow;

        // iterate to next row
        int (i + 1) -> i;

        // print the row out
        prn theRow;
    }

}

// computes the error of the board
fn:int computeError (N, representation) -> theError {

    int 0 -> theError;

    // compute the number of queens attacking each queen
    int 0 -> i;
    repeat N times {
        get_token(i, representation) -> token;
        int token -> itoken;
        int 0 -> e;
        int 0 -> k;
        repeat N times {
            get_token(k, representation) -> token;
            int token -> ktoken;
            ? (itoken == ktoken) {
                ? ( i != k) {
                    int (e + 1) -> e;
                }
            }
            ? (k < i) {
                ? (ktoken == (itoken - (i - k))) {
                    int (e + 1) -> e;
                } : {
                    ? (ktoken == (itoken - (k - i))) {
                        int (e + 1) -> e;
                    }
                }
            } : {
                ? (k > i) {
                    ? (ktoken == (itoken + (k - i))) {
                        int (e + 1) -> e;
                    } : {
                        if(ktoken == (itoken + (i - k))) {
                            int (e + 1) -> e;
                        }
                    }
                }
            }
            int (k + 1) -> k;
        }
        int (i + 1) -> i;
        int (theError + e) -> theError;
    }
}

start {

    args 0 -> nstr;
    int nstr -> N;

    // initialize the representation
    call initialize (N) -> representation;

    // minimize error
    call computeError (N, representation) -> error;
    int error -> currentError;
    int 1 -> moveBy;
    while (currentError != 0) {
        int 0 -> count;
        repeat N times {
            get_token(count, representation) -> tok;
            int tok -> itok;
            list representation -> oldRep;
            ?((itok + moveBy) >= N) {
                int ((itok + moveBy) % (N - 1)) -> amount;
                string amount -> strtok;
                set_token(count, representation, strtok) -> representation;
            } : {
                int (itok + moveBy) -> itok;
                string itok -> strtok;
                set_token(count, representation, strtok) -> representation;
            }

            // now compute new error based on update
            call computeError (N, representation) -> error;

            // now based on update decide whether to keep or go
            // back to original
            ?(error <= currentError) {
                int error -> currentError;
            } : {
                list oldRep -> representation;
            }

            int (N - 1) -> value;
            random_int(value) -> randomValue;
            int (moveBy + randomValue) -> moveBy;
            ?(moveBy >= (N - 1)) {
                int 1 -> moveBy;
            }

            int (count + 1) -> count;
        }

        pr "Error: ";
        prn currentError;
    }

    // print out the board representation
    call showBoard (N, representation);

}
