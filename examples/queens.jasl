;;; ----------------------------------------------
;;; A script to solve the N-Queens problem,
;;; a problem whereby no queen should be attacked
;;; by another queen.
;;; For example, for 8-queens, the solution might
;;; eventually be:
;;;
;;; [- - - - - - Q -]
;;; [- - - Q - - - -]
;;; [- Q - - - - - -]
;;; [- - - - - - - Q]
;;; [- - - - - Q - -]
;;; [Q - - - - - - -]
;;; [- - Q - - - - -]
;;; [- - - - Q - - -]
;;; ----------------------------------------------

fn:list initialize (N) -> rep {

    ;;; build the representation
    list [] -> rep;
    int 0 -> i;
    ;;; board initialization with heuristic
    repeat N times {
        string i -> istring;
        add_token(istring, rep);
        put (i + 2) -> i;
        ? (i = N) {
            put 0 -> i;
        }
    }
}

block showBoard (N, representation) {

    ;;; create one of the rows of the board
    list [] -> row;
    repeat N times {
        add_token ("-", row);
    }

    ;;; create the board representation
    int 0 -> i;
    repeat N times {
        ;;; make sure correct '-' is set with a 'Q'
        get_token(i, representation) -> token;

        ;;; token is a string to needs to be
        ;;; converted to an int
        int token -> itoken;

        ;;; now set the token to a 'Q'
        set_token(itoken, row, "Q") -> theRow;

        ;;; iterate to next row
        put (i + 1) -> i;

        ;;; print the row out
        prn theRow;
    }

}

;;; computes the error of the board
fn:int computeError (N, representation) -> theError {

    int 0 -> theError;

    ;;; compute the number of queens attacking each queen
    int 0 -> i;
    repeat N times {
        get_token(i, representation) -> token;
        int token -> itoken;
        int 0 -> e;
        int 0 -> k;
        repeat N times {
            get_token(k, representation) -> token;
            int token -> ktoken;
            ? (itoken = ktoken) {
                ? ( i /= k) {
                    put (e + 1) -> e;
                }
            }
            ? (k < i) {
                ? (ktoken = (itoken - (i - k))) {
                    put (e + 1) -> e;
                } : {
                    ? (ktoken = (itoken - (k - i))) {
                        put (e + 1) -> e;
                    }
                }
            } : {
                ? (k > i) {
                    ? (ktoken = (itoken + (k - i))) {
                        put (e + 1) -> e;
                    } : {
                        if(ktoken = (itoken + (i - k))) {
                            put (e + 1) -> e;
                        }
                    }
                }
            }
            int (k + 1) -> k;
        }
        put (i + 1) -> i;
        put (theError + e) -> theError;
    }
}

start {

    args 0 -> nstr;
    int nstr -> N;

    ;;; initialize the representation
    call initialize (N) -> representation;

    ;;; minimize error
    call computeError (N, representation) -> error;
    int error -> currentError;
    int 1 -> moveBy;
    int 0 -> count;

    while (currentError /= 0) {
        put 0 -> count;
        repeat N times {
            get_token(count, representation) -> tok;
            int tok -> itok;
            list representation -> oldRep;
            ?((itok + moveBy) >= N) {
                int ((itok + moveBy) % (N - 1)) -> amount;
                string amount -> strtok;
                set_token(count, representation, strtok) -> representation;
            } : {
                int (itok + moveBy) -> itok;
                string itok -> strtok;
                set_token(count, representation, strtok) -> representation;
            }

            ;;; now compute new error based on update
            call computeError (N, representation) -> error;

            ;;; now based on update decide whether to keep or go
            ;;; back to original
            ?(error <= currentError) {
                put error -> currentError;
            } : {
                put oldRep -> representation;
            }

            ;;; generate a random integer in the range [0, value]
            int (N - 1) -> value;
            random:int value -> randomValue;

            ;;; update amount to move by, by randomValue amount
            put (moveBy + randomValue) -> moveBy;

            ;;; bounds check
            ?(moveBy >= (N - 1)) {
                put 1 -> moveBy;
            }

            put (count + 1) -> count;
        }

        pr "Error: ";
        prn currentError;
    }

    ;;; print out the board representation
    call showBoard (N, representation);

}
