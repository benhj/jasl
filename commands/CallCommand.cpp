//
//  CallCommand.hpp
//  jasl
//
//  Created by Ben Jones on on 10/03/2015.
//  Copyright (c) 2015 Ben Jones. All rights reserved.
//


#include "CallCommand.hpp"
#include "ParamExtractor.hpp"
#include "../GlobalCache.hpp"
#include "../CommandInterpretor.hpp"
#include <vector>

namespace jasl 
{
    CallCommand::CallCommand(Function &func_, 
                             SharedVarCache const &sharedCache,
                             OptionalOutputStream const &output)
    : Command(func_, std::move(sharedCache), std::move(output))
    {
    }

    bool CallCommand::execute()
    {

        std::string functionName; 
        (void)m_func.getValueA<std::string>(functionName, m_sharedCache);

        // try to extract input arguments, if there are any
        ValueArray array;
        if(m_func.getValueB<ValueArray>(array, m_sharedCache)) {
            extractAndUpdateParams(array, m_sharedCache, GlobalCache::bigCache);
        }

        // check if call statement expecting a returnable in
        // which case we search for returnable rather than block
        // functions
        std::string returnSymbol;
        if(m_func.getValueC<std::string>(returnSymbol, m_sharedCache)) {
            return searchForFunction(functionName, 
                                     "returnable",
                                     returnSymbol);
        }

        return searchForFunction(functionName);
    }

    bool CallCommand::searchForFunction(std::string &functionName,
                                        std::string const &kind,
                                        std::string const &returnSymbol)
    {
        // First get all subroutines
        std::string &scriptString = GlobalCache::script;
        CommandInterpretor ci;
        auto functions = ci.parseStringCollection(scriptString);

        // Find all functions that are block functions
        decltype(functions) matched;
        for(auto &f : functions) {
            std::string funcName;
            if (f.name.find(kind) != std::string::npos) {
                matched.push_back(f);
            }
        }

        // Second, search for block with given name
        auto it = std::find_if(std::begin(matched), std::end(matched), [&](Function &f) { 

            std::string name;
            if(kind == "block") {
                (void)f.getValueA<std::string>(name, m_sharedCache);
            } else if(kind == "returnable") {
                (void)f.getValueB<std::string>(name, m_sharedCache);
            }
            return name == functionName;
        });

        // function was found so execute it
        if (it != std::end(matched)) {

            return parseCommand(*it, kind, returnSymbol);
        } 
        return false;
    }

    bool CallCommand::parseCommand(Function &function, 
                                   std::string const &kind,
                                   std::string const &returnSymbol)
    {
        CommandInterpretor ci;
        (void)ci.interpretFunc(function, m_sharedCache, m_outputStream);

        // now set result of function if returnable type
        if(kind == "returnable") {

            // what is the return type?
            std::string type;
            (void)function.getValueA<std::string>(type, m_sharedCache);

            // what is the name of the returned variable
            std::string returnName;
            (void)function.getValueD<std::string>(returnName, m_sharedCache);

            // now set the returned variable in the returnSymbol
            // and erase the original function result
            // Note, values reurned from the function are on
            // the global stack so need to access from GlobalCache
            if(type == "integer") {
                int64_t value;
                (void)GlobalCache::getInt_(returnName, value);
                m_sharedCache->setInt(returnSymbol, value);
            } else if(type == "decimal") {
                auto result = GlobalCache::getDouble(returnName);
                m_sharedCache->setDouble(returnSymbol, *result);
            } else if(type == "string") {
                auto result = GlobalCache::getString(returnName);
                m_sharedCache->setString(returnSymbol, *result);
            } else if(type == "boolean") {
                auto result = GlobalCache::getBool(returnName);
                m_sharedCache->setBool(returnSymbol, *result);
            } else if(type == "list") {
                auto result = GlobalCache::getList(returnName);
                m_sharedCache->setList(returnSymbol, *result);
            } else {
                setLastErrorMessage("call returnable: unknown return type");
                return false;
            }

            // to introduce some notion of variable locality,
            // erase the variable generated by the function itself
            GlobalCache::eraseValue(returnName);

        }

        return true;
    }
}